# ü©π AutoPatch Framework - API Specification

## √úbersicht

Das AutoPatch Framework erm√∂glicht automatische Real-Time Synchronisation von Objekten zwischen Server und Client √ºber SignalR und JsonPatch. Das Framework ist generisch und transparent - einmal aktiviert werden Objekte automatisch aktuell gehalten ohne weiteren Code-Aufwand.

## Konzept

- **Server-driven Updates**: Server ist Single Source of Truth
- **Automatisches Patching**: JsonPatch aktualisiert lokale Objekte transparent
- **UI Integration**: √úber INotifyPropertyChanged werden UI-Updates automatisch getriggert
- **Minimale API**: Nur Subscribe/Unsubscribe, der Rest passiert automatisch
- **Bidirektionale Sync**: Optional k√∂nnen Clients auch √Ñnderungen zur√ºck zum Server senden
- **Intelligent Throttling**: Batch-Queue System f√ºr Performance-Optimierung

## Use Cases

- Live-Dashboards (Sensoren, Alarmanlagen)
- Real-Time Tracking (Personen, Fahrzeuge, Ger√§te)
- Status-Monitoring (System Health, Prozesse)
- Live-Feeds (Events, Notifications)

---

## Server API

### Services registrieren

```csharp
services.AddAutoPatch(options => 
{
    options.DefaultThrottleInterval = TimeSpan.FromMilliseconds(100);
    options.MaxBatchSize = 50; // Optional: Maximale Batch-Gr√∂√üe
});
```

### Objekt-Typen registrieren

```csharp
services.AddAutoPatch()
    .AddObjectType<SensorStatus>(config => 
    {
        config.KeyProperty = x => x.Id;
        config.ExcludeProperties = new[] { "InternalId", "TempData" };
        config.ClientChangePolicy = ClientChangePolicy.Auto; // Auto | RequireConfirmation | Reject
        config.ThrottleInterval = TimeSpan.FromMilliseconds(50); // Override per Type
    })
    .AddObjectType<PersonLocation>(config =>
    {
        config.KeyProperty = x => x.PersonId;
        config.ClientChangePolicy = ClientChangePolicy.Reject; // Read-only f√ºr Clients
        config.ThrottleInterval = TimeSpan.FromMilliseconds(200); // Langsamere Updates
    })
    .AddChangeHandler<SensorStatus, SensorChangeHandler>()
    .AddChangeHandler<PersonLocation, PersonChangeHandler>();
```

**ClientChangePolicy Optionen:**
- **Auto**: Client-√Ñnderungen werden sofort √ºbernommen und gebroadcastet
- **RequireConfirmation**: Server validiert Client-√Ñnderungen vor √úbernahme
- **Reject**: Server lehnt alle Client-√Ñnderungen ab (Read-only Mode)

**Change Handler:**
- **IChangeHandler<T>**: Interface f√ºr Validation und Apply Logic
- **ValidateAsync**: Wird nur bei RequireConfirmation Policy aufgerufen
- **ApplyAsync**: Wird immer aufgerufen bei erfolgreicher Validation

**Throttling Configuration:**
- **ThrottleInterval**: Minimaler Abstand zwischen Batch-Sends
- **MaxBatchSize**: Maximale Anzahl Updates pro Batch (verhindert Memory-Issues)

### SignalR Integration

```csharp
services.AddSignalR()
    .AddAutoPatch();  // Registriert automatisch die Hubs
```

### Usage

```csharp
// Single Operations
_autoPatchService.NotifyChanged(sensorObject);
_autoPatchService.NotifyDeleted<SensorStatus>(sensorId);
_autoPatchService.NotifyAdded(newSensor);

// Bulk Operations
_autoPatchService.NotifyChanged(sensorObjects); // IEnumerable<T>
_autoPatchService.NotifyDeleted<SensorStatus>(sensorIds); // IEnumerable<TKey>
_autoPatchService.NotifyAdded(newSensors); // IEnumerable<T>

// Batch Operations (mixed)
_autoPatchService.NotifyBatch(batch => 
{
    batch.Changed(sensorObjects);
    batch.Deleted<SensorStatus>(sensorIds);
    batch.Added(newSensors);
});
```

### Throttling Verhalten

```csharp
// Beispiel: Hochfrequente Sensor-Updates
0ms:  _autoPatchService.NotifyChanged(sensor); // Temp = 25
      // ‚Üí Queue: [Patch1], Timer start (50ms f√ºr SensorStatus)
      
10ms: _autoPatchService.NotifyChanged(sensor); // Humidity = 80
      // ‚Üí Queue: [Patch1, Patch2]
      
30ms: _autoPatchService.NotifyChanged(sensor); // Status = "Alert"
      // ‚Üí Queue: [Patch1, Patch2, Patch3]
      
50ms: Timer expires
      // ‚Üí Send Batch: [Patch1, Patch2, Patch3] via SignalR
      // ‚Üí Queue = []
```

---

## Client API

### Services registrieren

```csharp
services.AddAutoPatch();
```

### Objekt-Typen konfigurieren

```csharp
services.AddAutoPatch()
    .AddObjectType<SensorStatus>(config => 
    {
        config.KeyProperty = x => x.Id;  // Key Accessor f√ºr Object Matching
        config.ChangeTracking = ChangeTrackingMode.ManualCommit; // Disabled | ManualCommit | AutoCommit
    })
    .AddObjectType<PersonLocation>(config =>
    {
        config.KeyProperty = x => x.PersonId;
        config.ChangeTracking = ChangeTrackingMode.Disabled; // Default: Kein Tracking
    });
```

**ChangeTrackingMode Optionen:**
- **Disabled**: Kein automatisches Change Tracking (Default)
- **ManualCommit**: Automatic Tracking, Manual CommitChanges erforderlich  
- **AutoCommit**: Automatic Tracking + sofortiger Commit bei √Ñnderungen

### Client verwenden

```csharp
IAutoPatchClient client = serviceProvider.GetService<IAutoPatchClient>();

// Connection Management
await client.StartAsync(cancellationToken); // Verbindet zu SignalR Hub
// ... Subscriptions sind nur bei aktiver Connection m√∂glich
await client.StopAsync(cancellationToken);  // Trennt Verbindung, beh√§lt Subscriptions in Memory
```

**Optional: Automatischer Start mit HostedService** (nicht verf√ºgbar in .NET MAUI)
```csharp
services.AddAutoPatch()
    .AddHostedService(); // Startet automatisch mit der App
```

### Subscriben

```csharp
// Subscribe mit Policy-Info Response
var sensors = new List<SensorStatus>();
var subscribeResult = await client.SubscribeAsync<SensorStatus>(sensors);

// Policy-Info f√ºr UI-Anpassungen nutzen
if (subscribeResult.CanEdit)
{
    editButton.IsEnabled = true;
    statusLabel.Text = "Live editing enabled";
}
else
{
    editButton.IsEnabled = false;
    statusLabel.Text = "Read-only mode";
}

// Oder spezifische Policy pr√ºfen
switch (subscribeResult.ClientChangePolicy)
{
    case ClientChangePolicy.Auto:
        ShowInstantEditingUI();
        break;
    case ClientChangePolicy.RequireConfirmation:
        ShowConfirmationEditingUI();
        break;
    case ClientChangePolicy.Reject:
        ShowReadOnlyUI();
        break;
}
```

**SubscribeResult Properties:**
- `ClientChangePolicy`: Server-Policy f√ºr diesen Objekttyp
- `CanEdit`: Shortcut f√ºr Policy != Reject
- `RequiresConfirmation`: Shortcut f√ºr Policy == RequireConfirmation
- `InitialData`: Die initial geladenen Objekte

Das Framework:
1. Holt initial alle Objekte vom Server
2. F√ºllt die √ºbergebene Liste
3. Gibt SubscribeResult mit Server-Policy zur√ºck
4. Startet Live-Updates via SignalR
5. Wendet JsonPatch-Batches automatisch auf die Objekte an (matched via KeyProperty)

### Unsubscriben

```csharp
await client.Unsubscribe<SensorStatus>();
await client.Unsubscribe<PersonLocation>();
```

### Error Handling

```csharp
client.OnError += (exception) => HandleError(exception);
client.OnConnectionLost += () => ShowOfflineMode();
client.OnReconnected += () => 
{
    HideOfflineMode();
    // Alle Subscriptions werden automatisch reaktiviert
};
```

### Bidirektionale Sync (Optional)

**Automatisches Change Tracking:**
Framework subscribes auf INotifyPropertyChanged und detektiert √Ñnderungen automatisch.

**Manual Commit mit direktem Result:**
CommitChanges gibt sofort das Server-Result zur√ºck (via SignalR Hub Method).

**Success/Error Handling:**
Developer erh√§lt direktes Feedback und kann entsprechend reagieren (UI Update, Error Messages, etc.).

---

## Throttling System

### Konzept

Das Throttling-System verhindert Performance-Probleme bei hochfrequenten Updates durch ein intelligentes Batch-Queue System.

### Funktionsweise

1. **Update kommt rein** ‚Üí Add to Queue
2. **Timer-Check:** "Ist Send-Timer bereits aktiv?"
3. **Nein:** Starte Timer (ThrottleInterval)
4. **Timer expires:** Send komplette Queue als Batch, leere Queue

### Batch-Verarbeitung

**Server-seitig:**
- Updates werden in Type-spezifischen Queues gesammelt
- Timer pro Objekttyp verhindert zu h√§ufige Sends
- Batch wird als Array von JsonPatch-Operationen gesendet

**Client-seitig:**
- Empf√§ngt Array von JsonPatches
- Wendet alle Patches sequenziell an
- Erh√§lt alle √Ñnderungen in korrekter Reihenfolge

### Beispiel-Szenario

```csharp
// Hochfrequente Sensor-Updates:
0ms:  sensor.Temperature = 25     ‚Üí Queue: [TempPatch], Timer start (100ms)
10ms: sensor.Humidity = 80        ‚Üí Queue: [TempPatch, HumidityPatch]
50ms: sensor.Status = "Alert"     ‚Üí Queue: [TempPatch, HumidityPatch, StatusPatch]
60ms: sensor.Temperature = 26     ‚Üí Queue: [TempPatch, HumidityPatch, StatusPatch, TempPatch2]
100ms: Timer expires ‚Üí Send Batch mit 4 Patches

// Client wendet alle 4 Patches nacheinander an:
// 1. Temperature: 20 ‚Üí 25
// 2. Humidity: 60 ‚Üí 80  
// 3. Status: "OK" ‚Üí "Alert"
// 4. Temperature: 25 ‚Üí 26
```

### Vorteile

- **Performance**: Reduziert SignalR-Overhead erheblich
- **Vollst√§ndigkeit**: Keine Updates gehen verloren
- **Reihenfolge**: Alle √Ñnderungen werden korrekt angewendet
- **Flexibilit√§t**: ThrottleInterval pro Objekttyp konfigurierbar
- **Einfachheit**: Keine komplexe Aggregation oder State-Tracking erforderlich

### Konfiguration

```csharp
.AddObjectType<SensorStatus>(config => 
{
    config.ThrottleInterval = TimeSpan.FromMilliseconds(50);  // Schnelle Updates
})
.AddObjectType<PersonLocation>(config =>
{
    config.ThrottleInterval = TimeSpan.FromMilliseconds(500); // Langsamere Updates
})
.AddObjectType<SystemHealth>(config =>
{
    config.ThrottleInterval = TimeSpan.Zero; // Kein Throttling - sofortige Updates
});
```

---

## Technische Details

### Server-seitig
- SignalR Hub mit Gruppen pro Objekttyp
- Event-driven Change Detection mit Throttling-Queues
- Automatische JsonPatch Generierung
- Batch-Broadcast an subscribte Clients
- Timer-basierte Queue-Verarbeitung pro Objekttyp

### Client-seitig
- Automatisches Connection Management
- Batch JsonPatch Application auf lokale Objekte
- INotifyPropertyChanged f√ºr UI-Updates
- Transparente Reconnection
- Optional: Bidirektionale Sync mit automatischem Change Tracking

### Datenfluss

**Server ‚Üí Client (Standard):**
1. **Initial**: Client subscribed ‚Üí Server sendet komplette Objektliste
2. **Updates**: Server Events ‚Üí Queue ‚Üí Timer ‚Üí Batch JsonPatch generiert ‚Üí an Gruppe gesendet ‚Üí Client wendet Patches an
3. **UI**: Objekte √§ndern sich ‚Üí PropertyChanged ‚Üí UI updated automatisch

**Client ‚Üí Server (Bidirektional, Optional):**
1. **Change Detection**: Objekt √§ndert sich ‚Üí PropertyChanged ‚Üí Framework detects
2. **Dirty Tracking**: Objekt als dirty markiert (wenn AutoCommit = false)
3. **Commit**: Manual oder Auto ‚Üí JsonPatch generiert ‚Üí an Server gesendet
4. **Server Processing**: Validation nach ClientChangePolicy ‚Üí Accept/Reject
5. **Broadcast**: Bei Accept ‚Üí Patch an alle anderen Clients (mit Throttling)

### Throttling-Pipeline

```
Object Change ‚Üí Queue Check ‚Üí Timer Management ‚Üí Batch Creation ‚Üí SignalR Send
     ‚Üì              ‚Üì              ‚Üì               ‚Üì              ‚Üì
 NotifyChanged ‚Üí Add to Queue ‚Üí Start/Reset ‚Üí JsonPatch Array ‚Üí Hub.SendToGroup
                     ‚Üì         Timer (50ms)        ‚Üì              ‚Üì
               Track per Type      ‚Üì         Serialize Batch ‚Üí All Subscribers
                     ‚Üì         On Expire          ‚Üì              ‚Üì
              {SensorStatus: []}    ‚Üì      [{op:"replace",...}] ‚Üí Client Apply
```

## Vorteile

- **Bandwidth-effizient**: Nur Deltas werden √ºbertragen, gebatcht f√ºr minimalen Overhead
- **Developer-freundlich**: Minimale API, maximale Automation
- **UI-Integration**: Nahtlos mit Data Binding
- **Skalierbar**: Nutzt SignalR-Infrastruktur mit intelligentem Throttling
- **Robust**: Automatische Reconnection und Error Handling
- **Performance-optimiert**: Batch-System verhindert Flooding bei hochfrequenten Updates

## Erweiterungen (Zukunft)

- Filtering bei Subscribe
- Conditional Updates
- Custom Serialization
- Offline Support mit Sync beim Reconnect
- Custom Validation Handlers f√ºr ClientChangePolicy
- Conflict Resolution Strategies
- Priority-based Throttling
- Adaptive Throttling basierend auf Network Conditions
