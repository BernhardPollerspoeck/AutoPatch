name: Build, Test, and Publish NuGet Packages

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      increment_version:
        description: "Version increment type"
        type: choice
        options:
          - none
          - patch
          - minor
          - major
        default: "none"

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup .NET 9
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'
    
    - name: Update version if requested
      if: github.event_name == 'workflow_dispatch' && github.event.inputs.increment_version != 'none'
      shell: pwsh
      run: |
        # Read current version from Directory.Build.props
        [xml]$buildProps = Get-Content "Directory.Build.props"
        $currentVersion = $buildProps.Project.PropertyGroup.Version
        
        # Parse version components
        $major, $minor, $patch = $currentVersion.Split('.')
        
        # Increment based on selected option
        switch ("${{ github.event.inputs.increment_version }}") {
          "major" {
            $major = [int]$major + 1
            $minor = 0
            $patch = 1
          }
          "minor" {
            $minor = [int]$minor + 1
            $patch = 1
          }
          "patch" {
            $patch = [int]$patch + 1
          }
        }
        
        # Create new version
        $newVersion = "$major.$minor.$patch"
        echo "Updating version from $currentVersion to $newVersion"
        
        # Update version in Directory.Build.props
        $buildProps.Project.PropertyGroup.Version = $newVersion
        $buildProps.Save((Resolve-Path "Directory.Build.props"))
        
        # Set environment variable for later steps
        echo "PACKAGE_VERSION=$newVersion" >> $GITHUB_ENV
    
    - name: Get version from Directory.Build.props
      if: github.event_name != 'workflow_dispatch' || github.event.inputs.increment_version == 'none'
      shell: pwsh
      run: |
        [xml]$buildProps = Get-Content "Directory.Build.props"
        $version = $buildProps.Project.PropertyGroup.Version
        echo "PACKAGE_VERSION=$version" >> $GITHUB_ENV
    
    - name: Restore dependencies
      run: dotnet restore
    
    - name: Build
      run: dotnet build --configuration Debug  # Use Debug for better coverage information
    
    - name: Install coverage tools
      run: |
        dotnet tool install --global coverlet.console
        dotnet tool install --global dotnet-reportgenerator-globaltool
    
    - name: Create coverage directory
      run: mkdir -p coverage
    
    - name: Run tests with coverage
      run: |
        echo "Running tests with coverage collection..."
        
        # Core Tests
        coverlet ./test/Autopatch.Core.Tests/bin/Debug/net9.0/Autopatch.Core.Tests.dll \
          --target "dotnet" \
          --targetargs "test ./test/Autopatch.Core.Tests/Autopatch.Core.Tests.csproj --no-build" \
          --format "cobertura" \
          --output "./coverage/Autopatch.Core.Tests.coverage.cobertura.xml"
        
        # Server Tests
        coverlet ./test/Autopatch.Server.Tests/bin/Debug/net9.0/Autopatch.Server.Tests.dll \
          --target "dotnet" \
          --targetargs "test ./test/Autopatch.Server.Tests/Autopatch.Server.Tests.csproj --no-build" \
          --format "cobertura" \
          --output "./coverage/Autopatch.Server.Tests.coverage.cobertura.xml"
        
        # Client Tests
        coverlet ./test/Autopatch.Client.Tests/bin/Debug/net9.0/Autopatch.Client.Tests.dll \
          --target "dotnet" \
          --targetargs "test ./test/Autopatch.Client.Tests/Autopatch.Client.Tests.csproj --no-build" \
          --format "cobertura" \
          --output "./coverage/Autopatch.Client.Tests.coverage.cobertura.xml"
      continue-on-error: true
    
    - name: Find coverage files
      run: |
        echo "Looking for coverage files..."
        find ./coverage -type f || echo "No coverage files found in coverage directory"
    
    - name: Generate code coverage report
      run: |
        reportgenerator \
          -reports:"./coverage/*.xml" \
          -targetdir:"./coveragereport" \
          -reporttypes:"HtmlInline_AzurePipelines;Cobertura;Badges"
      continue-on-error: true
    
    - name: Upload coverage report artifact
      uses: actions/upload-artifact@v4
      with:
        name: CoverageReport
        path: coveragereport
      continue-on-error: true
    
    - name: Create NuGet packages
      run: dotnet pack --configuration Release --output packages
    
    - name: Upload NuGet packages artifact
      uses: actions/upload-artifact@v4
      with:
        name: NuGetPackages
        path: packages/*.nupkg
    
    - name: Debug publishing information
      run: |
        echo "Event name: ${{ github.event_name }}"
        echo "Branch ref: ${{ github.ref }}"
        
        # List the packages that would be published
        echo "Packages to publish:"
        ls -la packages/*.nupkg
        
        # Check if NUGET_API_KEY is set (don't print the actual value)
        if [ -n "${{ secrets.NUGET_API_KEY }}" ]; then
          echo "NUGET_API_KEY is set"
        else
          echo "NUGET_API_KEY is NOT set"
        fi
    
    - name: Publish NuGet packages
      run: |
        echo "Publishing packages to NuGet.org..."
        dotnet nuget push "packages/*.nupkg" --api-key ${{ secrets.NUGET_API_KEY }} --source https://api.nuget.org/v3/index.json --skip-duplicate
    
    - name: Tag version in repository
      run: |
        git config --global user.name 'GitHub Actions'
        git config --global user.email 'actions@github.com'
        git tag -a "v${{ env.PACKAGE_VERSION }}" -m "Release v${{ env.PACKAGE_VERSION }}"
        git push origin "v${{ env.PACKAGE_VERSION }}"
